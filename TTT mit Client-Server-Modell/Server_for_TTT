"""
Tic Tac Toe Server:
Der Server beinhaltet die Spiellogik von Tic Tac Toe.
Das bedeutet, dass der Server die Spielzüge überprüft und den Gewinner ermittelt.
Dadurch das der Client keine Spiellogik hat, müssen die Spieldaten zum Server gesendet werden.
Dieser wertet die Daten aus und schickt die Ergebnisse dem Client zurück.
Dies ist nötig damit auf beiden Seiden die GUI aktualisiert wird und der Spielstand synchron ist.
"""


import socket
import pickle
# pickle wird verwendet, um die Daten zu serialisieren und zu deserialisieren
import tkinter as tk
from threading import Thread

# Server-Klasse
class TicTacToeServer:
    def __init__(self, master):
        self.master = master # Tkinter-Objekt
        self.master.title("Tic Tac Toe Server") # Titel des Fensters
        self.create_widgets() # Widgets erstellen
        self.initialize_game() # Spiel initialisieren
        # Sock_Stream ist ein TCP-Socket und wird für die Kommunikation zwischen Client und Server verwendet
        self.server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM) # Server-Socket erstellen
        self.server_socket.bind(('localhost', 123456)) # Server-Socket an Adresse und Port binden
        self.server_socket.listen(1)# Server-Socket lauscht auf eingehende Verbindungen
        Thread(target=self.wait_for_client).start() # Thread für die Verbindungsaufnahme mit dem Client
    
    # Widgets erstellen
    def create_widgets(self):
        self.buttons = [tk.Button(self.master, text=' ', font='Arial 20',  
        width=5, height=2,command=lambda i=i: self.make_move(i)) for i in range(9)] # Buttons für das Spielfeld erstellen
        # Buttons in einem 3x3 Raster anordnen
        for i, button in enumerate(self.buttons):
            row, col = divmod(i, 3)
            button.grid(row=row, column=col) # Buttons im Raster platzieren
        self.status_label = tk.Label(self.master, text="Waiting for client to connect...") # Label für den Status erstellen
        self.status_label.grid(row=3, column=0, columnspan=3) # Label im Fenster platzieren
        self.reset_button = tk.Button(self.master, text="New Game", state=tk.DISABLED, command=self.reset_game)
        self.reset_button.grid(row=4, column=0, columnspan=3) # Button im Fenster platzieren

    # neues Spiel initialisieren 
    def initialize_game(self):
        self.board = [' ' for _ in range(9)] # Spielfeld erstellen
        self.current_turn = 'X' # Spieler X beginnt
        self.winner = None # Variable für den Gewinner

    # Warten auf Client-Verbindung
    def wait_for_client(self):
        self.client_socket, self.client_address = self.server_socket.accept() # Client-Verbindung akzeptieren
        self.status_label.config(text=f"Client connected from {self.client_address}") # Status aktualisieren
        Thread(target=self.receive_state).start() # Thread für den Empfang von Daten vom Client starten
        self.update_buttons() # Buttons aktualisieren

    # Spielzug machen
    def make_move(self, index):
        if self.board[index] == ' ' and self.current_turn == 'X': # Überprüfen, ob das Feld leer ist und ob Spieler X an der Reihe ist
            self.board[index] = 'X' # Spielzug machen und Feld mit X markieren 
            if self.check_winner('X'): # Überprüfen, ob Spieler X gewonnen hat 
                self.winner = 'X' # Spieler X hat gewonnen 
            elif self.check_draw(): # Überprüfen, ob es ein Unentschieden gibt
                self.winner = 'Draw' # Unentschieden 
            self.current_turn = 'O' # Spielerwechsel zu O 
            self.update_buttons() # Buttons aktualisieren 
            self.send_state() # Spielzustand an Client senden
    # Buttons aktualisieren
    def update_buttons(self):	
        for i, button in enumerate(self.buttons): # Alle Buttons durchgehen 
            button.config(text=self.board[i], 
            state=tk.DISABLED if self.board[i] != ' ' else tk.NORMAL) # Button-Text und -Status aktualisieren
        if self.winner: # Überprüfen, ob es einen Gewinner gibt 
            self.status_label.config(text=f"Winner: {self.winner}" if self.winner != 'Draw' else "It's a draw!") # Status aktualisieren
            for button in self.buttons: # Alle Buttons durchgehen 
                button.config(state=tk.DISABLED) # Buttons deaktivieren 
            self.reset_button.config(state=tk.NORMAL) # Reset-Button aktivieren
        else: # Wenn es keinen Gewinner gibt 
            self.status_label.config(text=f"Current turn: {self.current_turn}") # Status aktualisieren
    
    # Spielzustand an Client senden 
    def receive_state(self): 
        while True:
            data = self.client_socket.recv(4096) # Daten vom Client empfangen 
            if not data: # Wenn keine Daten empfangen wurden
                break 
            move = pickle.loads(data) # Daten deserialisieren
            if move == 'reset': # Wenn das Spiel zurückgesetzt werden soll
                self.initialize_game() # Spiel zurücksetzen
            else: 
                self.process_move(move) # Spielzug verarbeiten
            self.update_buttons() # Buttons aktualisieren
    # Spielzustand an Client senden
    def process_move(self, move):
        index, player = move # Spielzug und Spieler auspacken
        if self.board[index] == ' ' and player == self.current_turn: # Überprüfen, ob das Feld leer ist und ob der richtige Spieler am Zug ist
            self.board[index] = player # Spielzug machen und Feld markieren
            if self.check_winner(player): # Überprüfen, ob der Spieler gewonnen hat
                self.winner = player # Spieler hat gewonnen
            elif self.check_draw(): # Überprüfen, ob es ein Unentschieden gibt
                self.winner = 'Draw' # Unentschieden 
            self.current_turn = 'X' # Spielerwechsel
    # Funktion zur Gewinnüberprüfung
    def check_winner(self, player):
        win_conditions = [(0, 1, 2), (3, 4, 5), (6, 7, 8),
                          (0, 3, 6), (1, 4, 7), (2, 5, 8),
                          (0, 4, 8), (2, 4, 6)]
        for condition in win_conditions:
        # Wenn alle Felder in einer Gewinnkombi gleich sind, gibt es einen Gewinner
            if all(self.board[i] == player for i in condition):
                return True
        return False
    # Überprüfen, ob es ein Unentschieden gibt
    def check_draw(self): 
        return all(space != ' ' for space in self.board) # Wenn alle Felder belegt sind, gibt es ein Unentschieden 

    # Spielzustand an Client senden
    def send_state(self):
        state = (self.board, self.current_turn, self.winner) # Spielzustand in Tupel packen 
        self.client_socket.sendall(pickle.dumps(state)) # Spielzustand serialisieren und an Client senden 

    # Spiel zurücksetzen 
    def reset_game(self):
        self.initialize_game() # Spiel zurücksetzen 
        self.update_buttons() # Buttons aktualisieren
        self.status_label.config(text="Current turn: X") # Status aktualisieren
        self.reset_button.config(state=tk.DISABLED) # Reset-Button deaktivieren 
        self.send_state() # Spielzustand an Client senden 

# Hauptprogramm 
if __name__ == "__main__":
    root = tk.Tk() # Tkinter-Objekt erstellen 
    server = TicTacToeServer(root) # Server-Objekt erstellen
    root.mainloop() # Tkinter-Schleife starten